import { Directive, EventEmitter, Input, Output } from '@angular/core';
import { LeafletUtil } from '../../core/leaflet.util';
import { LeafletDirectiveWrapper } from '../../core/leaflet.directive.wrapper';
import { LeafletControlLayersWrapper } from '../control/leaflet-control-layers.wrapper';
import * as i0 from "@angular/core";
import * as i1 from "../../core/leaflet.directive";
/**
 * Baselayers directive
 *
 * This directive is provided as a convenient way to add baselayers to the map. The input accepts
 * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is
 * used to determine what changed so that layers are appropriately added or removed. This directive
 * will also add the layers control so users can switch between available base layers.
 *
 * To specify which layer to show as the 'active' baselayer, you will want to add it to the map
 * using the layers directive. Otherwise, the plugin will use the last one it sees.
 */
class LeafletBaseLayersDirective {
    // Set/get baseLayers
    set baseLayers(v) {
        this.baseLayersValue = v;
        this.updateBaseLayers();
    }
    get baseLayers() {
        return this.baseLayersValue;
    }
    constructor(leafletDirective, differs, zone) {
        this.differs = differs;
        this.zone = zone;
        // Output for once the layers control is ready
        this.layersControlReady = new EventEmitter();
        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);
        this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);
        this.baseLayersDiffer = this.differs.find({}).create();
    }
    ngOnDestroy() {
        this.baseLayers = {};
        if (null != this.controlLayers.getLayersControl()) {
            this.controlLayers.getLayersControl().remove();
        }
    }
    ngOnInit() {
        // Init the map
        this.leafletDirective.init();
        // Create the control outside angular to prevent events from triggering chnage detection
        this.zone.runOutsideAngular(() => {
            // Initially configure the controlLayers
            this.controlLayers
                .init({}, this.layersControlOptions)
                .addTo(this.leafletDirective.getMap());
        });
        this.updateBaseLayers();
    }
    ngDoCheck() {
        this.updateBaseLayers();
    }
    updateBaseLayers() {
        const map = this.leafletDirective.getMap();
        const layersControl = this.controlLayers.getLayersControl();
        if (null != map && null != layersControl && null != this.baseLayersDiffer) {
            const changes = this.baseLayersDiffer.diff(this.baseLayersValue);
            const results = this.controlLayers.applyBaseLayerChanges(changes);
            if (results.changed()) {
                this.syncBaseLayer();
            }
        }
    }
    /**
     * Check the current base layer and change it to the new one if necessary
     */
    syncBaseLayer() {
        const map = this.leafletDirective.getMap();
        const layers = LeafletUtil.mapToArray(this.baseLayers);
        let foundLayer;
        // Search all the layers in the map to see if we can find them in the baselayer array
        map.eachLayer((l) => {
            foundLayer = layers.find((bl) => (l === bl));
        });
        // Did we find the layer?
        if (null != foundLayer) {
            // Yes - set the baselayer to the one we found
            this.baseLayer = foundLayer;
        }
        else {
            // No - set the baselayer to the first in the array and add it to the map
            if (layers.length > 0) {
                this.baseLayer = layers[0];
                // Add layers outside of angular to prevent events from triggering change detection
                this.zone.runOutsideAngular(() => {
                    this.baseLayer.addTo(map);
                });
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.1", ngImport: i0, type: LeafletBaseLayersDirective, deps: [{ token: i1.LeafletDirective }, { token: i0.KeyValueDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.1", type: LeafletBaseLayersDirective, selector: "[leafletBaseLayers]", inputs: { baseLayers: ["leafletBaseLayers", "baseLayers"], layersControlOptions: ["leafletLayersControlOptions", "layersControlOptions"] }, outputs: { layersControlReady: "leafletLayersControlReady" }, ngImport: i0 }); }
}
export { LeafletBaseLayersDirective };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.1", ngImport: i0, type: LeafletBaseLayersDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[leafletBaseLayers]'
                }]
        }], ctorParameters: function () { return [{ type: i1.LeafletDirective }, { type: i0.KeyValueDiffers }, { type: i0.NgZone }]; }, propDecorators: { baseLayers: [{
                type: Input,
                args: ['leafletBaseLayers']
            }], layersControlOptions: [{
                type: Input,
                args: ['leafletLayersControlOptions']
            }], layersControlReady: [{
                type: Output,
                args: ['leafletLayersControlReady']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGVhZmxldC1iYXNlbGF5ZXJzLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1sZWFmbGV0L3NyYy9saWIvbGF5ZXJzL2Jhc2UvbGVhZmxldC1iYXNlbGF5ZXJzLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUFXLFlBQVksRUFBRSxLQUFLLEVBQy9CLE1BQU0sRUFDZCxNQUFNLGVBQWUsQ0FBQztBQUl2QixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFdEQsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDL0UsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sMkNBQTJDLENBQUM7OztBQUd4Rjs7Ozs7Ozs7OztHQVVHO0FBQ0gsTUFHYSwwQkFBMEI7SUFTdEMscUJBQXFCO0lBQ3JCLElBQ0ksVUFBVSxDQUFDLENBQTRCO1FBQzFDLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO1FBRXpCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFDRCxJQUFJLFVBQVU7UUFDYixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7SUFDN0IsQ0FBQztJQWNELFlBQVksZ0JBQWtDLEVBQVUsT0FBd0IsRUFBVSxJQUFZO1FBQTlDLFlBQU8sR0FBUCxPQUFPLENBQWlCO1FBQVUsU0FBSSxHQUFKLElBQUksQ0FBUTtRQVR0Ryw4Q0FBOEM7UUFDVCx1QkFBa0IsR0FBRyxJQUFJLFlBQVksRUFBa0IsQ0FBQztRQVM1RixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSx1QkFBdUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ3RFLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSwyQkFBMkIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxrQkFBa0Is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QUM7YUFDSDtTQUNEO0lBRUYsQ0FBQzs4R0FuSFcsMEJBQTBCO2tHQUExQiwwQkFBMEI7O1NBQTFCLDBCQUEwQjsyRkFBMUIsMEJBQTBCO2tCQUh0QyxTQUFTO21CQUFDO29CQUNWLFFBQVEsRUFBRSxxQkFBcUI7aUJBQy9COzBKQVlJLFVBQVU7c0JBRGIsS0FBSzt1QkFBQyxtQkFBbUI7Z0JBV1ksb0JBQW9CO3NCQUF6RCxLQUFLO3VCQUFDLDZCQUE2QjtnQkFHQyxrQkFBa0I7c0JBQXRELE1BQU07dUJBQUMsMkJBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0RGlyZWN0aXZlLCBEb0NoZWNrLCBFdmVudEVtaXR0ZXIsIElucHV0LCBLZXlWYWx1ZURpZmZlciwgS2V5VmFsdWVEaWZmZXJzLCBOZ1pvbmUsIE9uRGVzdHJveSxcblx0T25Jbml0LCBPdXRwdXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENvbnRyb2wsIExheWVyIH0gZnJvbSAnbGVhZmxldCc7XG5cbmltcG9ydCB7IExlYWZsZXRVdGlsIH0gZnJvbSAnLi4vLi4vY29yZS9sZWFmbGV0LnV0aWwnO1xuaW1wb3J0IHsgTGVhZmxldERpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvcmUvbGVhZmxldC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTGVhZmxldERpcmVjdGl2ZVdyYXBwZXIgfSBmcm9tICcuLi8uLi9jb3JlL2xlYWZsZXQuZGlyZWN0aXZlLndyYXBwZXInO1xuaW1wb3J0IHsgTGVhZmxldENvbnRyb2xMYXllcnNXcmFwcGVyIH0gZnJvbSAnLi4vY29udHJvbC9sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLndyYXBwZXInO1xuXG5cbi8qKlxuICogQmFzZWxheWVycyBkaXJlY3RpdmVcbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSBpcyBwcm92aWRlZCBhcyBhIGNvbnZlbmllbnQgd2F5IHRvIGFkZCBiYXNlbGF5ZXJzIHRvIHRoZSBtYXAuIFRoZSBpbnB1dCBhY2NlcHRzXG4gKiBhIGtleS12YWx1ZSBtYXAgb2YgbGF5ZXIgbmFtZSAtPiBsYXllci4gTXV0YWJsZSBjaGFuZ2VkIGFyZSBkZXRlY3RlZC4gT24gY2hhbmdlcywgYSBkaWZmZXIgaXNcbiAqIHVzZWQgdG8gZGV0ZXJtaW5lIHdoYXQgY2hhbmdlZCBzbyB0aGF0IGxheWVycyBhcmUgYXBwcm9wcmlhdGVseSBhZGRlZCBvciByZW1vdmVkLiBUaGlzIGRpcmVjdGl2ZVxuICogd2lsbCBhbHNvIGFkZCB0aGUgbGF5ZXJzIGNvbnRyb2wgc28gdXNlcnMgY2FuIHN3aXRjaCBiZXR3ZWVuIGF2YWlsYWJsZSBiYXNlIGxheWVycy5cbiAqXG4gKiBUbyBzcGVjaWZ5IHdoaWNoIGxheWVyIHRvIHNob3cgYXMgdGhlICdhY3RpdmUnIGJhc2VsYXllciwgeW91IHdpbGwgd2FudCB0byBhZGQgaXQgdG8gdGhlIG1hcFxuICogdXNpbmcgdGhlIGxheWVycyBkaXJlY3RpdmUuIE90aGVyd2lzZSwgdGhlIHBsdWdpbiB3aWxsIHVzZSB0aGUgbGFzdCBvbmUgaXQgc2Vlcy5cbiAqL1xuQERpcmVjdGl2ZSh7XG5cdHNlbGVjdG9yOiAnW2xlYWZsZXRCYXNlTGF5ZXJzXSdcbn0pXG5leHBvcnQgY2xhc3MgTGVhZmxldEJhc2VMYXllcnNEaXJlY3RpdmVcblx0aW1wbGVtZW50cyBEb0NoZWNrLCBPbkRlc3Ryb3ksIE9uSW5pdCB7XG5cblx0Ly8gQmFzZSBMYXllcnNcblx0YmFzZUxheWVyc1ZhbHVlOiB7IFtuYW1lOiBzdHJpbmddOiBMYXllciB9O1xuXG5cdC8vIEJhc2UgTGF5ZXJzIE1hcCBEaWZmZXJcblx0YmFzZUxheWVyc0RpZmZlcjogS2V5VmFsdWVEaWZmZXI8c3RyaW5nLCBMYXllcj47XG5cblx0Ly8gU2V0L2dldCBiYXNlTGF5ZXJzXG5cdEBJbnB1dCgnbGVhZmxldEJhc2VMYXllcnMnKVxuXHRzZXQgYmFzZUxheWVycyh2OiB7IFtuYW1lOiBzdHJpbmddOiBMYXllciB9KSB7XG5cdFx0dGhpcy5iYXNlTGF5ZXJzVmFsdWUgPSB2O1xuXG5cdFx0dGhpcy51cGRhdGVCYXNlTGF5ZXJzKCk7XG5cdH1cblx0Z2V0IGJhc2VMYXllcnMoKTogeyBbbmFtZTogc3RyaW5nXTogTGF5ZXIgfSB7XG5cdFx0cmV0dXJuIHRoaXMuYmFzZUxheWVyc1ZhbHVlO1xuXHR9XG5cblx0Ly8gQ29udHJvbCBPcHRpb25zXG5cdEBJbnB1dCgnbGVhZmxldExheWVyc0NvbnRyb2xPcHRpb25zJykgbGF5ZXJzQ29udHJvbE9wdGlvbnM6IENvbnRyb2wuTGF5ZXJzT3B0aW9ucztcblxuXHQvLyBPdXRwdXQgZm9yIG9uY2UgdGhlIGxheWVycyBjb250cm9sIGlzIHJlYWR5XG5cdEBPdXRwdXQoJ2xlYWZsZXRMYXllcnNDb250cm9sUmVhZHknKSBsYXllcnNDb250cm9sUmVhZHkgPSBuZXcgRXZlbnRFbWl0dGVyPENvbnRyb2wuTGF5ZXJzPigpO1xuXG5cdC8vIEFjdGl2ZSBCYXNlIExheWVyXG5cdHByaXZhdGUgYmFzZUxheWVyOiBMYXllcjtcblxuXHRwcml2YXRlIGxlYWZsZXREaXJlY3RpdmU6IExlYWZsZXREaXJlY3RpdmVXcmFwcGVyO1xuXHRwcml2YXRlIGNvbnRyb2xMYXllcnM6IExlYWZsZXRDb250cm9sTGF5ZXJzV3JhcHBlcjtcblxuXHRjb25zdHJ1Y3RvcihsZWFmbGV0RGlyZWN0aXZlOiBMZWFmbGV0RGlyZWN0aXZlLCBwcml2YXRlIGRpZmZlcnM6IEtleVZhbHVlRGlmZmVycywgcHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHtcblx0XHR0aGlzLmxlYWZsZXREaXJlY3RpdmUgPSBuZXcgTGVhZmxldERpcmVjdGl2ZVdyYXBwZXIobGVhZmxldERpcmVjdGl2ZSk7XG5cdFx0dGhpcy5jb250cm9sTGF5ZXJzID0gbmV3IExlYWZsZXRDb250cm9sTGF5ZXJzV3JhcHBlcih0aGlzLnpvbmUsIHRoaXMubGF5ZXJzQ29udHJvbFJlYWR5KTtcblx0XHR0aGlzLmJhc2VMYXllcnNEaWZmZXIgPSB0aGlzLmRpZmZlcnMuZmluZCh7fSkuY3JlYXRlPHN0cmluZywgTGF5ZXI+KCk7XG5cdH1cblxuXHRuZ09uRGVzdHJveSgpIHtcblx0XHR0aGlzLmJhc2VMYXllcnMgPSB7fTtcblx0XHRpZiAobnVsbCAhPSB0aGlzLmNvbnRyb2xMYXllcnMuZ2V0TGF5ZXJzQ29udHJvbCgpKSB7XG5cdFx0XHR0aGlzLmNvbnRyb2xMYXllcnMuZ2V0TGF5ZXJzQ29udHJvbCgpLnJlbW92ZSgpO1xuXHRcdH1cblx0fVxuXG5cdG5nT25Jbml0KCkge1xuXG5cdFx0Ly8gSW5pdCB0aGUgbWFwXG5cdFx0dGhpcy5sZWFmbGV0RGlyZWN0aXZlLmluaXQoKTtcblxuXHRcdC8vIENyZWF0ZSB0aGUgY29udHJvbCBvdXRzaWRlIGFuZ3VsYXIgdG8gcHJldmVudCBldmVudHMgZnJvbSB0cmlnZ2VyaW5nIGNobmFnZSBkZXRlY3Rpb25cblx0XHR0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuXG5cdFx0XHQvLyBJbml0aWFsbHkgY29uZmlndXJlIHRoZSBjb250cm9sTGF5ZXJzXG5cdFx0XHR0aGlzLmNvbnRyb2xMYXllcnNcblx0XHRcdFx0LmluaXQoe30sIHRoaXMubGF5ZXJzQ29udHJvbE9wdGlvbnMpXG5cdFx0XHRcdC5hZGRUbyh0aGlzLmxlYWZsZXREaXJlY3RpdmUuZ2V0TWFwKCkpO1xuXG5cdFx0fSk7XG5cblx0XHR0aGlzLnVwZGF0ZUJhc2VMYXllcnMoKTtcblxuXHR9XG5cblx0bmdEb0NoZWNrKCkge1xuXHRcdHRoaXMudXBkYXRlQmFzZUxheWVycygpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHVwZGF0ZUJhc2VMYXllcnMoKSB7XG5cblx0XHRjb25zdCBtYXAgPSB0aGlzLmxlYWZsZXREaXJlY3RpdmUuZ2V0TWFwKCk7XG5cdFx0Y29uc3QgbGF5ZXJzQ29udHJvbCA9IHRoaXMuY29udHJvbExheWVycy5nZXRMYXllcnNDb250cm9sKCk7XG5cblx0XHRpZiAobnVsbCAhPSBtYXAgJiYgbnVsbCAhPSBsYXllcnNDb250cm9sICYmIG51bGwgIT0gdGhpcy5iYXNlTGF5ZXJzRGlmZmVyKSB7XG5cdFx0XHRjb25zdCBjaGFuZ2VzID0gdGhpcy5iYXNlTGF5ZXJzRGlmZmVyLmRpZmYodGhpcy5iYXNlTGF5ZXJzVmFsdWUpO1xuXHRcdFx0Y29uc3QgcmVzdWx0cyA9IHRoaXMuY29udHJvbExheWVycy5hcHBseUJhc2VMYXllckNoYW5nZXMoY2hhbmdlcyk7XG5cblx0XHRcdGlmIChyZXN1bHRzLmNoYW5nZWQoKSkge1xuXHRcdFx0XHR0aGlzLnN5bmNCYXNlTGF5ZXIoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayB0aGUgY3VycmVudCBiYXNlIGxheWVyIGFuZCBjaGFuZ2UgaXQgdG8gdGhlIG5ldyBvbmUgaWYgbmVjZXNzYXJ5XG5cdCAqL1xuXHRwcm90ZWN0ZWQgc3luY0Jhc2VMYXllcigpIHtcblxuXHRcdGNvbnN0IG1hcCA9IHRoaXMubGVhZmxldERpcmVjdGl2ZS5nZXRNYXAoKTtcblx0XHRjb25zdCBsYXllcnMgPSBMZWFmbGV0VXRpbC5tYXBUb0FycmF5KHRoaXMuYmFzZUxheWVycyk7XG5cdFx0bGV0IGZvdW5kTGF5ZXI6IExheWVyO1xuXG5cdFx0Ly8gU2VhcmNoIGFsbCB0aGUgbGF5ZXJzIGluIHRoZSBtYXAgdG8gc2VlIGlmIHdlIGNhbiBmaW5kIHRoZW0gaW4gdGhlIGJhc2VsYXllciBhcnJheVxuXHRcdG1hcC5lYWNoTGF5ZXIoKGw6IExheWVyKSA9PiB7XG5cdFx0XHRmb3VuZExheWVyID0gbGF5ZXJzLmZpbmQoKGJsKSA9PiAobCA9PT0gYmwpKTtcblx0XHR9KTtcblxuXHRcdC8vIERpZCB3ZSBmaW5kIHRoZSBsYXllcj9cblx0XHRpZiAobnVsbCAhPSBmb3VuZExheWVyKSB7XG5cdFx0XHQvLyBZZXMgLSBzZXQgdGhlIGJhc2VsYXllciB0byB0aGUgb25lIHdlIGZvdW5kXG5cdFx0XHR0aGlzLmJhc2VMYXllciA9IGZvdW5kTGF5ZXI7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gTm8gLSBzZXQgdGhlIGJhc2VsYXllciB0byB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGFuZCBhZGQgaXQgdG8gdGhlIG1hcFxuXHRcdFx0aWYgKGxheWVycy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHRoaXMuYmFzZUxheWVyID0gbGF5ZXJzWzBdO1xuXG5cdFx0XHRcdC8vIEFkZCBsYXllcnMgb3V0c2lkZSBvZiBhbmd1bGFyIHRvIHByZXZlbnQgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBjaGFuZ2UgZGV0ZWN0aW9uXG5cdFx0XHRcdHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5iYXNlTGF5ZXIuYWRkVG8obWFwKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cbn1cbiJdfQ==