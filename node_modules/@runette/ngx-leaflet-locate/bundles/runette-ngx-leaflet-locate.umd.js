(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('leaflet')) :
    typeof define === 'function' && define.amd ? define('@runette/ngx-leaflet-locate', ['exports', '@angular/core', 'leaflet'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.runette = global.runette || {}, global.runette["ngx-leaflet-locate"] = {}), global.ng.core, global.require$$0));
})(this, (function (exports, i0, require$$0) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);

    var L_Control_Locate_min$1 = { exports: {} };

    (function (module, exports) {
        !function (t, i) { "function" == typeof undefined && undefined.amd ? undefined(["leaflet"], t) : "object" == 'object' && (void 0 !== i && i.L ? module.exports = t(L) : module.exports = t(require$$0__default["default"])), void 0 !== i && i.L && (i.L.Control.Locate = t(L)); }(function (l) { var s = function (i, s, t) { (t = t.split(" ")).forEach(function (t) { l.DomUtil[i].call(this, s, t); }); }, i = function (t, i) { return s("addClass", t, i); }, o = function (t, i) { return s("removeClass", t, i); }; var t = l.Marker.extend({ initialize: function (t, i) { l.Util.setOptions(this, i), this._latlng = t, this.createIcon(); }, createIcon: function () { var t = this.options; var i = ""; void 0 !== t.color && (i += "stroke:" + t.color + ";"), void 0 !== t.weight && (i += "stroke-width:" + t.weight + ";"), void 0 !== t.fillColor && (i += "fill:" + t.fillColor + ";"), void 0 !== t.fillOpacity && (i += "fill-opacity:" + t.fillOpacity + ";"), void 0 !== t.opacity && (i += "opacity:" + t.opacity + ";"); t = this._getIconSVG(t, i); this._locationIcon = l.divIcon({ className: t.className, html: t.svg, iconSize: [t.w, t.h] }), this.setIcon(this._locationIcon); }, _getIconSVG: function (t, i) { var s = t.radius, t = s + t.weight, o = 2 * t; return { className: "leaflet-control-locate-location", svg: "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + o + "\" height=\"" + o + "\" version=\"1.1\" viewBox=\"-" + t + " -" + t + " " + o + " " + o + "\">" + '<circle r="' + s + '" style="' + i + '" /></svg>', w: o, h: o }; }, setStyle: function (t) { l.Util.setOptions(this, t), this.createIcon(); } }), e = t.extend({ initialize: function (t, i, s) { l.Util.setOptions(this, s), this._latlng = t, this._heading = i, this.createIcon(); }, setHeading: function (t) { this._heading = t; }, _getIconSVG: function (t, i) { var s = t.radius, o = t.width + t.weight, s = 2 * (s + t.depth + t.weight), t = "M0,0 l" + t.width / 2 + "," + t.depth + " l-" + o + ",0 z"; return { className: "leaflet-control-locate-heading", svg: "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + o + "\" height=\"" + s + "\" version=\"1.1\" viewBox=\"-" + o / 2 + " 0 " + o + " " + s + "\" style=\"" + ("transform: rotate(" + this._heading + "deg)") + "\">" + '<path d="' + t + '" style="' + i + '" /></svg>', w: o, h: s }; } }), t = l.Control.extend({ options: { position: "topleft", layer: void 0, setView: "untilPanOrZoom", keepCurrentZoomLevel: !1, initialZoomLevel: !1, getLocationBounds: function (t) { return t.bounds; }, flyTo: !1, clickBehavior: { inView: "stop", outOfView: "setView", inViewNotFollowing: "inView" }, returnToPrevBounds: !1, cacheLocation: !0, drawCircle: !0, drawMarker: !0, showCompass: !0, markerClass: t, compassClass: e, circleStyle: { className: "leaflet-control-locate-circle", color: "#136AEC", fillColor: "#136AEC", fillOpacity: .15, weight: 0 }, markerStyle: { className: "leaflet-control-locate-marker", color: "#fff", fillColor: "#2A93EE", fillOpacity: 1, weight: 3, opacity: 1, radius: 9 }, compassStyle: { fillColor: "#2A93EE", fillOpacity: 1, weight: 0, color: "#fff", opacity: 1, radius: 9, width: 9, depth: 6 }, followCircleStyle: {}, followMarkerStyle: {}, followCompassStyle: {}, icon: "leaflet-control-locate-location-arrow", iconLoading: "leaflet-control-locate-spinner", iconElementTag: "span", textElementTag: "small", circlePadding: [0, 0], metric: !0, createButtonCallback: function (t, i) { var t = l.DomUtil.create("a", "leaflet-bar-part leaflet-bar-part-single", t), s = (t.title = i.strings.title, t.href = "#", t.setAttribute("role", "button"), l.DomUtil.create(i.iconElementTag, i.icon, t)); return void 0 !== i.strings.text && (l.DomUtil.create(i.textElementTag, "leaflet-locate-text", t).textContent = i.strings.text, t.classList.add("leaflet-locate-text-active"), t.parentNode.style.display = "flex", 0 < i.icon.length) && s.classList.add("leaflet-locate-icon"), { link: t, icon: s }; }, onLocationError: function (t, i) { alert(t.message); }, onLocationOutsideMapBounds: function (t) { t.stop(), alert(t.options.strings.outsideMapBoundsMsg); }, showPopup: !0, strings: { title: "Show me where I am", metersUnit: "meters", feetUnit: "feet", popup: "You are within {distance} {unit} from this point", outsideMapBoundsMsg: "You seem located outside the boundaries of the map" }, locateOptions: { maxZoom: 1 / 0, watch: !0, setView: !1 } }, initialize: function (t) { for (var i_1 in t)
                "object" == typeof this.options[i_1] ? l.extend(this.options[i_1], t[i_1]) : this.options[i_1] = t[i_1]; this.options.followMarkerStyle = l.extend({}, this.options.markerStyle, this.options.followMarkerStyle), this.options.followCircleStyle = l.extend({}, this.options.circleStyle, this.options.followCircleStyle), this.options.followCompassStyle = l.extend({}, this.options.compassStyle, this.options.followCompassStyle); }, onAdd: function (t) { var i = l.DomUtil.create("div", "leaflet-control-locate leaflet-bar leaflet-control"), t = (this._container = i, this._map = t, this._layer = this.options.layer || new l.LayerGroup, this._layer.addTo(t), this._event = void 0, this._compassHeading = null, this._prevBounds = null, this.options.createButtonCallback(i, this.options)); return this._link = t.link, this._icon = t.icon, l.DomEvent.on(this._link, "click", function (t) { l.DomEvent.stopPropagation(t), l.DomEvent.preventDefault(t), this._onClick(); }, this).on(this._link, "dblclick", l.DomEvent.stopPropagation), this._resetVariables(), this._map.on("unload", this._unload, this), i; }, _onClick: function () { this._justClicked = !0; var i = this._isFollowing(); if (this._userPanned = !1, this._userZoomed = !1, this._active && !this._event)
                this.stop();
            else if (this._active) {
                var s = this.options.clickBehavior;
                var t_1 = s.outOfView;
                switch (t_1 = s[t_1 = this._map.getBounds().contains(this._event.latlng) ? i ? s.inView : s.inViewNotFollowing : t_1] ? s[t_1] : t_1) {
                    case "setView":
                        this.setView();
                        break;
                    case "stop": this.stop(), this.options.returnToPrevBounds && (this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds).bind(this._map)(this._prevBounds);
                }
            }
            else
                this.options.returnToPrevBounds && (this._prevBounds = this._map.getBounds()), this.start(); this._updateContainerStyle(); }, start: function () { this._activate(), this._event && (this._drawMarker(this._map), this.options.setView) && this.setView(), this._updateContainerStyle(); }, stop: function () { this._deactivate(), this._cleanClasses(), this._resetVariables(), this._removeMarker(); }, stopFollowing: function () { this._userPanned = !0, this._updateContainerStyle(), this._drawMarker(); }, _activate: function () { if (!this._active && this._map && (this._map.locate(this.options.locateOptions), this._map.fire("locateactivate", this), this._active = !0, this._map.on("locationfound", this._onLocationFound, this), this._map.on("locationerror", this._onLocationError, this), this._map.on("dragstart", this._onDrag, this), this._map.on("zoomstart", this._onZoom, this), this._map.on("zoomend", this._onZoomEnd, this), this.options.showCompass)) {
                var t_2 = "ondeviceorientationabsolute" in window;
                if (t_2 || "ondeviceorientation" in window) {
                    var i_2 = this, s_1 = function () { l.DomEvent.on(window, t_2 ? "deviceorientationabsolute" : "deviceorientation", i_2._onDeviceOrientation, i_2); };
                    DeviceOrientationEvent && "function" == typeof DeviceOrientationEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(function (t) { "granted" === t && s_1(); }) : s_1();
                }
            } }, _deactivate: function () { this._active && this._map && (this._map.stopLocate(), this._map.fire("locatedeactivate", this), this._active = !1, this.options.cacheLocation || (this._event = void 0), this._map.off("locationfound", this._onLocationFound, this), this._map.off("locationerror", this._onLocationError, this), this._map.off("dragstart", this._onDrag, this), this._map.off("zoomstart", this._onZoom, this), this._map.off("zoomend", this._onZoomEnd, this), this.options.showCompass) && (this._compassHeading = null, "ondeviceorientationabsolute" in window ? l.DomEvent.off(window, "deviceorientationabsolute", this._onDeviceOrientation, this) : "ondeviceorientation" in window && l.DomEvent.off(window, "deviceorientation", this._onDeviceOrientation, this)); }, setView: function () { var t; this._drawMarker(), this._isOutsideMapBounds() ? (this._event = void 0, this.options.onLocationOutsideMapBounds(this)) : this._justClicked && !1 !== this.options.initialZoomLevel ? (t = this.options.flyTo ? this._map.flyTo : this._map.setView).bind(this._map)([this._event.latitude, this._event.longitude], this.options.initialZoomLevel) : this.options.keepCurrentZoomLevel ? (t = this.options.flyTo ? this._map.flyTo : this._map.panTo).bind(this._map)([this._event.latitude, this._event.longitude]) : (t = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds, this._ignoreEvent = !0, t.bind(this._map)(this.options.getLocationBounds(this._event), { padding: this.options.circlePadding, maxZoom: this.options.initialZoomLevel || this.options.locateOptions.maxZoom }), l.Util.requestAnimFrame(function () { this._ignoreEvent = !1; }, this)); }, _drawCompass: function () { var t, i; this._event && (t = this._event.latlng, this.options.showCompass && t && null !== this._compassHeading && (i = this._isFollowing() ? this.options.followCompassStyle : this.options.compassStyle, this._compass ? (this._compass.setLatLng(t), this._compass.setHeading(this._compassHeading), this._compass.setStyle && this._compass.setStyle(i)) : this._compass = new this.options.compassClass(t, this._compassHeading, i).addTo(this._layer)), !this._compass || this.options.showCompass && null !== this._compassHeading || (this._compass.removeFrom(this._layer), this._compass = null)); }, _drawMarker: function () { void 0 === this._event.accuracy && (this._event.accuracy = 0); var t, i = this._event.accuracy, s = this._event.latlng; this.options.drawCircle && (t = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle, this._circle ? this._circle.setLatLng(s).setRadius(i).setStyle(t) : this._circle = l.circle(s, i, t).addTo(this._layer)); var o, e; e = this.options.metric ? (o = i.toFixed(0), this.options.strings.metersUnit) : (o = (3.2808399 * i).toFixed(0), this.options.strings.feetUnit), this.options.drawMarker && (t = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle, this._marker ? (this._marker.setLatLng(s), this._marker.setStyle && this._marker.setStyle(t)) : this._marker = new this.options.markerClass(s, t).addTo(this._layer)), this._drawCompass(); var n = this.options.strings.popup; function a() { return "string" == typeof n ? l.Util.template(n, { distance: o, unit: e }) : "function" == typeof n ? n({ distance: o, unit: e }) : n; } this.options.showPopup && n && this._marker && this._marker.bindPopup(a())._popup.setLatLng(s), this.options.showPopup && n && this._compass && this._compass.bindPopup(a())._popup.setLatLng(s); }, _removeMarker: function () { this._layer.clearLayers(), this._marker = void 0, this._circle = void 0; }, _unload: function () { this.stop(), this._map.off("unload", this._unload, this); }, _setCompassHeading: function (t) { !isNaN(parseFloat(t)) && isFinite(t) ? (t = Math.round(t), this._compassHeading = t, l.Util.requestAnimFrame(this._drawCompass, this)) : this._compassHeading = null; }, _onCompassNeedsCalibration: function () { this._setCompassHeading(); }, _onDeviceOrientation: function (t) { this._active && (t.webkitCompassHeading ? this._setCompassHeading(t.webkitCompassHeading) : t.absolute && t.alpha && this._setCompassHeading(360 - t.alpha)); }, _onLocationError: function (t) { 3 == t.code && this.options.locateOptions.watch || (this.stop(), this.options.onLocationError(t, this)); }, _onLocationFound: function (t) { if ((!this._event || this._event.latlng.lat !== t.latlng.lat || this._event.latlng.lng !== t.latlng.lng || this._event.accuracy !== t.accuracy) && this._active) {
                switch (this._event = t, this._drawMarker(), this._updateContainerStyle(), this.options.setView) {
                    case "once":
                        this._justClicked && this.setView();
                        break;
                    case "untilPan":
                        this._userPanned || this.setView();
                        break;
                    case "untilPanOrZoom":
                        this._userPanned || this._userZoomed || this.setView();
                        break;
                    case "always": this.setView();
                }
                this._justClicked = !1;
            } }, _onDrag: function () { this._event && !this._ignoreEvent && (this._userPanned = !0, this._updateContainerStyle(), this._drawMarker()); }, _onZoom: function () { this._event && !this._ignoreEvent && (this._userZoomed = !0, this._updateContainerStyle(), this._drawMarker()); }, _onZoomEnd: function () { this._event && this._drawCompass(), this._event && !this._ignoreEvent && this._marker && !this._map.getBounds().pad(-.3).contains(this._marker.getLatLng()) && (this._userPanned = !0, this._updateContainerStyle(), this._drawMarker()); }, _isFollowing: function () { return !!this._active && ("always" === this.options.setView || ("untilPan" === this.options.setView ? !this._userPanned : "untilPanOrZoom" === this.options.setView ? !this._userPanned && !this._userZoomed : void 0)); }, _isOutsideMapBounds: function () { return void 0 !== this._event && this._map.options.maxBounds && !this._map.options.maxBounds.contains(this._event.latlng); }, _updateContainerStyle: function () { this._container && (this._active && !this._event ? this._setClasses("requesting") : this._isFollowing() ? this._setClasses("following") : this._active ? this._setClasses("active") : this._cleanClasses()); }, _setClasses: function (t) { "requesting" == t ? (o(this._container, "active following"), i(this._container, "requesting"), o(this._icon, this.options.icon), i(this._icon, this.options.iconLoading)) : "active" == t ? (o(this._container, "requesting following"), i(this._container, "active"), o(this._icon, this.options.iconLoading), i(this._icon, this.options.icon)) : "following" == t && (o(this._container, "requesting"), i(this._container, "active following"), o(this._icon, this.options.iconLoading), i(this._icon, this.options.icon)); }, _cleanClasses: function () { l.DomUtil.removeClass(this._container, "requesting"), l.DomUtil.removeClass(this._container, "active"), l.DomUtil.removeClass(this._container, "following"), o(this._icon, this.options.iconLoading), i(this._icon, this.options.icon); }, _resetVariables: function () { this._active = !1, this._justClicked = !1, this._userPanned = !1, this._userZoomed = !1; } }); return l.control.locate = function (t) { return new l.Control.Locate(t); }, t; }, window);
        
    }(L_Control_Locate_min$1, L_Control_Locate_min$1.exports));
    var L_Control_Locate_min = L_Control_Locate_min$1.exports;

    /// <reference path="../../node_modules/@types/leaflet.locatecontrol/index.d.ts" />
    var NgxLeafletLocateComponent = /** @class */ (function () {
        function NgxLeafletLocateComponent() {
            this.location$ = new i0.EventEmitter;
            this.control = new require$$0.Control.Locate();
            this.options = {};
        }
        ;
        NgxLeafletLocateComponent.prototype.ngOnInit = function () {
        };
        ;
        NgxLeafletLocateComponent.prototype.ngOnDestroy = function () {
            var _a, _b, _c;
            if (this.control && this.map) {
                this.control.stop();
                (_a = this._map) === null || _a === void 0 ? void 0 : _a.off("unload", (_b = this.map) === null || _b === void 0 ? void 0 : _b._unload, this.control);
            }
            if (this._map && this.control)
                this._map.removeControl(this.control);
            (_c = this._map) === null || _c === void 0 ? void 0 : _c.off('locationfound');
        };
        ;
        Object.defineProperty(NgxLeafletLocateComponent.prototype, "map", {
            get: function () {
                return this._map;
            },
            set: function (map) {
                if (map) {
                    this._map = map;
                    this.control = require$$0.control.locate(this.options);
                    this.control.addTo(map);
                    var location$_1 = this.location$;
                    map.on('locationfound', function (e) {
                        location$_1.emit(e);
                    });
                }
            },
            enumerable: false,
            configurable: true
        });
        return NgxLeafletLocateComponent;
    }());
    NgxLeafletLocateComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxLeafletLocateComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    NgxLeafletLocateComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: NgxLeafletLocateComponent, selector: "leaflet-locate-control", inputs: { options: "options", map: "map" }, outputs: { location$: "location$" }, ngImport: i0__namespace, template: '', isInline: true });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxLeafletLocateComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'leaflet-locate-control',
                        template: '',
                        styleUrls: []
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { location$: [{
                    type: i0.Output
                }], options: [{
                    type: i0.Input
                }], map: [{
                    type: i0.Input
                }] } });

    var NgxLeafletLocateModule = /** @class */ (function () {
        function NgxLeafletLocateModule() {
        }
        return NgxLeafletLocateModule;
    }());
    NgxLeafletLocateModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxLeafletLocateModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    NgxLeafletLocateModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxLeafletLocateModule, declarations: [NgxLeafletLocateComponent], exports: [NgxLeafletLocateComponent] });
    NgxLeafletLocateModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxLeafletLocateModule, imports: [[]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxLeafletLocateModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [NgxLeafletLocateComponent],
                        imports: [],
                        exports: [
                            NgxLeafletLocateComponent,
                        ]
                    }]
            }] });

    /*
     * Public API Surface of ngx-leaflet-locate
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NgxLeafletLocateComponent = NgxLeafletLocateComponent;
    exports.NgxLeafletLocateModule = NgxLeafletLocateModule;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=runette-ngx-leaflet-locate.umd.js.map
